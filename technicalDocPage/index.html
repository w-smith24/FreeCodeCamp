<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  <title>freeCodeCamp Technical Documentation Page</title>
  
  
  
      <link rel="stylesheet" href="css/style.css">

  
</head>

<body>

  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">


<div id="main-body">
  <nav id="navbar">
    <span id="nav-header"><i class="fab fa-vuejs"></i><header>Vue.js</header></span>
    <a href="#Introduction" class="nav-link">Introduction</a>
    <a href="#The_Vue_Instance" class="nav-link">The Vue Instance</a>
    <a href="#Template_Syntax" class="nav-link">Template Syntax</a>
    <a href="#Conditional_Rendering" class="nav-link">Conditional Rendering</a>
    <a href="#Event_Handling" class="nav-link">Event Handling</a>
  </nav>

  <main id="main-doc">
    <section id="Introduction" class="main-section">
      <header>Introduction</header>
      <ul>
        <li>
          <h3>What is Vue.js?</h3>
          <hr>
          <p>Vue (pronounced /vjuː/, like <strong>view</strong>) is a <strong>progressive framework</strong> for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with <a class="green" href="https://vuejs.org/v2/guide/single-file-components.html">modern tooling</a> and <a class="green" href="https://github.com/vuejs/awesome-vue#components--libraries">supporting libraries</a>.</p>
        </li>
        <li>
          <h3>Declarative Rendering</h3>
          <hr>
          <p>At the core of Vue.js is a system that enables us to declaratively render data to the DOM using straightforward template syntax:</p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
  &lt;div id="app"&gt;
    {{ message }}
  &lt;/div&gt;
          </code></pre>
          <h5>Javascript</h5>
          <pre><code class="whole-line">
  var app = new Vue ({
    el: '#app',
    data: {
      message: 'Hello Vue!'
    }
  })
          </code></pre>
          <h5>Result</h5>
          <div id="app" class="demo">{{ message }}</div>
          <p>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now reactive. How do we know? Open your browser’s JavaScript console (right now, on this page) and set <code class="orange">app.message</code> to a different value. You should see the rendered example above update accordingly.</p>
          <p>In addition to text interpolation, we can also bind element attributes like this:</p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
  &lt;div id="app-2"&gt;
    &lt;span v-bind:title="message"&gt;
      Hover your mouse over me for a few seconds
      to see my dynamically bound title!
    &lt;/span&gt;
  &lt;/div&gt;
          </code></pre>
          <h5>Javascript</h5>
          <pre><code class="whole-line">
  var app2 = new Vue ({
    el: '#app-2',
    data: {
      message: 'You loaded this page on ' new Date().tolocaleString()
    }
  })
          </code></pre>
          <h5>Result</h5>
          <div id="app-2" class="demo">
            <span v-bind:title="message">
              Hover your mouse over me for a few seconds to see my dynamically bound title!
            </span>
          </div>
          <p>Here we are encountering something new. The <code class="orange">v-bind</code> attribute you are seeing is called a <strong>directive</strong>. Directives are prefixed with <code class="orange">v-</code> to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying “keep this element’s <code class="orange">title</code> attribute up-to-date with the <code class="orange">message</code> property on the Vue instance.”</p>
          <p>If you open up your JavaScript console again and enter <code class="orange">app2.message = 'some new message'</code>, you’ll once again see that the bound HTML - in this case the <code class="orange">title</code> attribute - has been updated.</p>
        </li>
        <li>
          <h3>Conditionals and Loops</h3>
          <hr>
          <p>It’s easy to toggle the presence of an element, too:</p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
&lt;div id="app-3"&gt;
  &lt;span v-if="seen"&gt;Now you see me&lt;/span&gt;
&lt;/div&gt;
          </code></pre>
          <h5>Javascript</h5>
          <pre><code class="whole-line">
var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})          
          </code></pre>
          <h5>Result</h5>
          <div id="app-3" class="demo">
            <span v-if="seen">Now you see me</span>
          </div>
          <p>Go ahead and enter <code class="orange">app3.seen = false</code> in the console. You should see the message disappear.</p>
          <p>This example demonstrates that we can bind data to not only text and attributes, but also the <strong>structure</strong> of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply <a class="green" href="https://vuejs.org/v2/guide/transitions.html">transition effects</a> when elements are inserted/updated/removed by Vue.</p>
          <p>There are quite a few other directives, each with its own special functionality. For example, the <code class="orange">v-for</code> directive can be used for displaying a list of items using the data from an Array:</p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
&lt;div id="app-4"&gt;
  &lt;ol&gt;
    &lt;li v-for="todo in todos"&gt;
      {{ todo.text }}
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;          
          </code></pre>
          <h5>Javascript</h5>
          <pre><code class="whole-line">
var app4 = new Vue({
  el: '#app-4',
  data: {
    todos: [
      { text: 'Learn JavaScript' },
      { text: 'Learn Vue' },
      { text: 'Build something awesome' }
    ]
  }
})          
          </code></pre>
          <h5>Result</h5>
          <div id="app-4" class="demo">
            <ol>
              <li v-for="todo in todos">
                {{ todo.text }}
              </li>
            </ol>
          </div>
          <p>In the console, enter <code class="orange">app4.todos.push({ text: 'New item' })</code>. You should see a new item appended to the list.</p>
        </li>
        <li>
          <h3>Handling User Input</h3>
          <hr>
          <p>To let users interact with your app, we can use the <code class="orange">v-on</code> directive to attach event listeners that invoke methods on our Vue instances:</p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
&lt;div id="app-5"&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button v-on:click="reverseMessage"&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;          
          </code></pre>
          <h5>Javascript</h5>
          <pre><code class="whole-line">
var app5 = new Vue({
  el: '#app-5',
  data: {
    message: 'Hello Vue.js!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})          
          </code></pre>
          <h5>Result</h5>
          <div id="app-5" class="demo">
            <p>{{ message }}</p>
            <button v-on:click="reverseMessage">Reverse Message</button>
          </div>
          <p>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</p>
          <p>Vue also provides the <code class="orange">v-model</code> directive that makes two-way binding between form input and app state a breeze:</p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
&lt;div id="app-6"&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;input v-model="message"&gt;
&lt;/div&gt;          
          </code></pre>
          <h5>Javascript</h5>
          <pre><code class="whole-line">
var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})          
          </code></pre>
          <h5>Result</h5>
          <div id="app-6" class="demo">
            <p>{{ message }}</p>
            <input v-model="message">
          </div>
        </li>
        <li>
          <h3>Composing with Components</h3>
          <hr>
          <p>The component system is another important concept in Vue, because it’s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:</p>
          <img src="https://vuejs.org/images/components.png?_sw-precache=b5c08269dfc26ae6d7db3801e9efd296" alt="Component Tree" width="85%">
          <p>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</p>
          <h5>Javascript</h5>
          <pre><code class="whole-line">
// Define a new component called todo-item
Vue.component('todo-item', {
  template: '&lt;li&gt;This is a todo&lt;/li&gt;'
})          
          </code></pre>
          <p>Now you can compose it in another component’s template:</p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
&lt;ol&gt;
  <!-- Create an instance of the todo-item component -->
  &lt;todo-item&gt;&lt;/todo-item&gt;
&lt;/ol&gt;          
          </code></pre>
          <p>But this would render the same text for every todo, which is not super interesting. We should be able to pass data from the parent scope into child components. Let’s modify the component definition to make it accept a prop:</p>\
          <h5>Javascript</h5>
          <pre><code class="whole-line">
Vue.component('todo-item', {
  // The todo-item component now accepts a
  // "prop", which is like a custom attribute.
  // This prop is called todo.
  props: ['todo'],
  template: '&lt;li&gt;{{ todo.text }}&lt;/li&gt;'
})          
          </code></pre>
          <p>Now we can pass the todo into each repeated component using <code class="orange">v-bind:</code></p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
&lt;div id="app-7"&gt;
  &lt;ol&gt;
    &lt;!--
      Now we provide each todo-item with the todo object
      it's representing, so that its content can be dynamic.
      We also need to provide each component with a "key",
      which will be explained later.
    --&gt;
    &lt;todo-item
      v-for="item in groceryList"
      v-bind:todo="item"
      v-bind:key="item.id"
    &gt;&lt;/todo-item&gt;
  &lt;/ol&gt;
&lt;/div&gt;          
          </code></pre>
          <h5>Javascript</h5>
          <pre><code class="whole-line">
Vue.component('todo-item', {
  props: ['todo'],
  template: '&lt;li&gt;{{ todo.text }}&lt;/li&gt;'
})

var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { id: 0, text: 'Vegetables' },
      { id: 1, text: 'Cheese' },
      { id: 2, text: 'Whatever else humans are supposed to eat' }
    ]
  }
})          
          </code></pre>
          <h5>Result</h5>
          <div id="app-7" class="demo">
            <ol>
              <todo-item
                v-for="item in groceryList"
                v-bind:todo="item"
                v-bind:key="item.id"
              ></todo-item>
            </ol>            
          </div>
          <p>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our <code class="orange">&lt;todo-item&gt;</code> component with more complex template and logic without affecting the parent app.</p>
          <p>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components <a class="green" href="https://vuejs.org/v2/guide/components.html">later in the guide</a>, but here’s an (imaginary) example of what an app’s template might look like with components:</p>
          <h5>HTML</h5>
          <pre><code class="whole-line">
&lt;div id="app"&gt;
  &lt;app-nav&gt;&lt;/app-nav&gt;
  &lt;app-view&gt;
    &lt;app-sidebar&gt;&lt;/app-sidebar&gt;
    &lt;app-content&gt;&lt;/app-content&gt;
  &lt;/app-view&gt;
&lt;/div&gt;          
          </code></pre>
          <h4>Relation to Custom Elements</h4>
          <p>You may have noticed that Vue components are very similar to <strong>Custom Elements</strong>, which are part of the <a class="green" href="https://www.w3.org/wiki/WebComponents/">Web Components Spec</a>. That’s because Vue’s component syntax is loosely modeled after the spec. For example, Vue components implement the <a class="green" href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Slot API</a> and the <code class="orange">is</code> special attribute. However, there are a few key differences:</p>
          <ol>
            <li>
              <p>The Web Components Spec has been finalized, but is not natively implemented in every browser. Safari 10.1+, Chrome 54+ and Firefox 63+ natively support web components. In comparison, Vue components don’t require any polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can also be wrapped inside a native custom element.</p>
            </li>
            <li>
              <p>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</p>
            </li>
          </ol>
        </li>
      </ul>
    </section>
    <section id="The_Vue_Instance" class="main-section">
      <header>The Vue Instance</header>
      <p>Every Vue application starts by creating a new <strong>Vue instance</strong> with the <code class="orange">Vue</code> function:</p>
      <pre><code class="whole-line">
var vm = new Vue({
  // options
})      
      </code></pre>
      <p>Although not strictly associated with the <a class="green" href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM pattern</a>, Vue’s design was partly inspired by it. As a convention, we often use the variable <codce class="orange">vm</code> (short for ViewModel) to refer to our Vue instance.</p>
      <p>When you create a Vue instance, you pass in an <strong>options object</strong>. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the <a class="green" href="https://vuejs.org/v2/api/#Options-Data">API reference</a>.</p>
      <p>A Vue application consists of a <strong>root Vue instance</strong> created with <code class="orange">new Vue</code>, optionally organized into a tree of nested, reusable components. For example, a todo app’s component tree might look like this:</p>
      <pre><code class="whole-line">
Root Instance
└─ TodoList
   ├─ TodoItem
   │  ├─ DeleteTodoButton
   │  └─ EditTodoButton
   └─ TodoListFooter
      ├─ ClearTodosButton
      └─ TodoListStatistics      
      </code></pre>
      <p>We’ll talk about the <a class="green" href="https://vuejs.org/v2/guide/components.html">component system</a> in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</p>
      <p>View the rest of this section <a class="green" href="https://vuejs.org/v2/guide/instance.html">here</a></p>
    </section>
    <section id="Template_Syntax" class="main-section">
      <header>Template Syntax</header>
      <p>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance’s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</p>
      <p>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</p>
      <p>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also <a class="green" href="https://vuejs.org/v2/guide/render-function.html">directly write render functions</a> instead of templates, with optional JSX support.</p>
      <p>View the rest of this section <a class="green" href="https://vuejs.org/v2/guide/syntax.html">here</a></p>
    </section>
    <section id="Conditional_Rendering" class="main-section">
      <header>Conditional Rendering</header>
      <h3><code class="orange large">v-if</code></h3>
      <hr>
      <p>The directive <code class="orange">v-if</code> is used to conditionally render a block. The block will only be rendered if the directive’s expression returns a truthy value.</p>
      <pre><code class="whole-line">
&lt;h1 v-if="awesome"&gt;Vue is awesome!&lt;/h1&gt;
      </code></pre>
      <p>It is also possible to add an “else block” with <code class="orange">v-else</code>:</p>
      <pre><code class="whole-line">
&lt;h1 v-if="awesome"&gt;Vue is awesome!&lt;/h1&gt;
&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;     
      </code></pre>
      <p>View the rest of this section <a class="green" href="https://vuejs.org/v2/guide/conditional.html">here</a></p>
    </section>
    <section id="Event_Handling" class="main-section">
      <header>Event Handling</header>
      <h3>Listening to Events</h3>
      <hr>
      <p>We can use the v-on directive to listen to DOM events and run some JavaScript when they’re triggered <br><br>
For example:</p>
      <h5>HTML</h5>
      <pre><code class="whole-line">
&lt;div id="example-1"&gt;
  &lt;button v-on:click="counter += 1"&gt;Add 1&lt;/button&gt;
  &lt;p&gt;The button above has been clicked {{ counter }} times.&lt;/p&gt;
&lt;/div&gt;      
      </code></pre>
      <h5>Javascript</h5>
      <pre><code class="whole-line">
var example1 = new Vue({
  el: '#example-1',
  data: {
    counter: 0
  }
})      
      </code></pre>
      <h5>Result</h5>
      <div id="example-1" class="demo">
        <button v-on:click="counter += 1">Add 1</button>
        <p>The button above has been clicked {{ counter }} times.</p>
      </div>
      <h3>Method Event Handlers</h3>
      <hr>
      <p>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the v-on attribute isn’t feasible. That’s why v-on can also accept the name of a method you’d like to call. <br><br> For example:</p>
      <h5>HTML</h5>
      <pre><code class="whole-line">
&lt;div id="example-2"&gt;
  &lt;!-- `greet` is the name of a method defined below --&gt;
  &lt;button v-on:click="greet"&gt;Greet&lt;/button&gt;
&lt;/div&gt;      
      </code></pre>
      <h5>Javascript</h5>
      <pre><code class="whole-line">
var example2 = new Vue({
  el: '#example-2',
  data: {
    name: 'Vue.js'
  },
  // define methods under the `methods` object
  methods: {
    greet: function (event) {
      // `this` inside methods points to the Vue instance
      alert('Hello ' + this.name + '!')
      // `event` is the native DOM event
      if (event) {
        alert(event.target.tagName)
      }
    }
  }
})

// you can invoke methods in JavaScript too
example2.greet() // => 'Hello Vue.js!'  
      </code></pre>
      <h5>Result</h5>
      <div id="example-2" class="demo">
        <button v-on:click="greet">Greet</button>
      </div>
      <p>View the rest of this section <a class="green" href="https://vuejs.org/v2/guide/events.html">here</a></p>
      <p>Everthing in this page is taken from the Vue.js Docs <a class="green" href="https://vuejs.org/v2/guide/">HERE</a></p>
    </section>
  </main>
</div>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.7/vue.min.js'></script>

  

    <script src="js/index.js"></script>




</body>

</html>
